<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Home Work</title>
  </head>
  <body>
    <script>
      // если все елементы массива это квадрат числа то вернуть true.
      // если все елементы массива не являются квадратом числа, то вернуть false.
      // если передан пустой массив, то вернуть undefined

      function isSquare(arr) {
        let arr2 = arr.map(Math.sqrt);
        let arr3 = arr2.map((array) => array ** 2);
        let num = 0;
        for (i = 0; i < arr.length; i++) {
          if (arr[i] !== arr3[i]) {
            num += 1;
          }
        }
        if (arr.length === 0) {
          return undefined;
        } else if (num > 0) {
          return false;
        } else if (num === 0) {
          return true;
        }
      }

      // 7 Kata
      // Завершите функцию, которая принимает строковый параметр и переворачивает каждое слово в строке. Все пробелы в строке должны быть сохранены.

      // Примеры
      // "This is an example!" ==> "sihT si na !elpmaxe"
      // "double  spaces"      ==> "elbuod  secaps"

      function reverseWords(str) {
        let arr = str.split(" ");
        let newArr = [];
        for (i = 0; i < arr.length; i++) {
          newArr.push(arr[i].split("").reverse().join(""));
        }
        return newArr.join(" ");
      }

      // 7 Kata
      // Ваша задача — написать функцию, которая принимает строку и возвращает новую строку, в которой удалены все гласные.
      // Примечание: для этой ката Y не считается гласной.

      function word(str) {
        let letter = ["A", "E", "I", "O", "U", "a", "e", "i", "o", "u"];
        // let arr = str.split("");
        // let filtered = arr.filter((item) => !letter.includes(item));
        // let res = filtered.join("");
        // return res
        return str
          .split("")
          .filter((item) => !letter.includes(item))
          .join("");
      }

      // Напишите функцию, которая проверяет, является ли заданная строка (без учета регистра) палиндромом .

      function itsPalindrom(x) {
        return (
          x.toLowerCase("") === x.toLowerCase().split("").reverse().join("")
        );
      }

      // функция проверят, являются ли числа массива палиндромом, если да, то возвращает 1 в массив, иначе 0

      function numPalindrom(arr) {
        let arr2 = arr
          .join(" ")
          .split("")
          .reverse()
          .join("")
          .split(" ")
          .reverse();
        let arr3 = [];
        for (i = 0; i < arr2.length; i++) {
          if (arr2[i] == arr[i]) {
            arr3.push(1);
          } else if (arr2[i] != arr[i]) {
            arr3.push(0);
          }
        }
        return arr3;
      }

      // Завершите решение так, чтобы оно возвращало сумму всех чисел, кратных 3 или 5 , меньше переданного числа. Кроме того, если число отрицательное, верните 0
      // Примечание. Если число кратно и 3, и 5, считайте его только один раз .

      function solition(n) {
        let arr = [];
        for (i = 1; i < n; i++) {
          if (n <= 0) {
            arr.push(0);
          } else if (i % 3 === 0 || i % 5 === 0) {
            arr.push(i);
          } else if (i % 3 === 0 && i % 5 === 0) {
            arr.push(i);
          }
        }
        let arrTotal = arr.reduce((acc, val) => acc + val, 0);
        return arrTotal;
      }

      //Нарциссическое число (или число Армстронга) — это положительное число, представляющее собой сумму собственных цифр, каждая из которых возведена в степень количества цифр в данном основании.
      //Например, возьмем 153 (3 цифры), что является самовлюбленным:

      //     1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
      // и 1652 (4 цифры), что не является:

      //     1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938

      function narcissistic(value) {
        let num = String(value);
        let sum = 0;
        for (i = 0; i < num.length; i++) {
          sum += num[i] ** num.length;
        }
        return value === sum ? true : false;
      }

      // построить пирамиду из символов "*" высота которой будет соответствовать числу которое принимает функция.
      // например башня с 5 этажами выглядит так:
      // [
      // "     *     ",
      // "    ***    ",
      // "   *****   ",
      // "  *******  ",
      // " ********* ",
      // "***********"
      // ]

      function tower(num) {
        let star = "*";
        let space = " ";
        let arr = [];
        for (i = 0; i < num; i++) {
          arr.push(
            space.repeat(num - i - 1) +
              star.repeat(i * 2 + 1) +
              space.repeat(num - 1 - i)
          );
        }
        return arr;
      }

      //процентная разница от стартового числа
      function findePercent(a, b) {
        let c = a / 100;
        if (b > a) {
          return (b - a) / c;
        } else {
          return (a + b) / c;
        }
      }

      // Likes check
      function likes(arr) {
        if (arr.length == 0) {
          return "no one likes this";
        } else if (arr.length == 1) {
          return `${arr[0]} likes this`;
        } else if (arr.length == 2) {
          return `${arr[0]} and ${arr[1]} like this`;
        } else if (arr.length == 3) {
          return `${arr[0]}, ${arr[1]} and ${arr[2]} like this`;
        } else if (arr.length > 3) {
          return `${arr[0]}, ${arr[1]} and ${arr.length - 2} others like this`;
        }
      }

      // количество позиций, в которых входные строки не совпадают.
      function hamming(a, b) {
        arr1 = a.split("");
        arr2 = b.split("");
        let count = 0;
        for (i = 0; i < arr1.length; i++) {
          arr1[i] === arr2[i] ? (count += 0) : (count += 1);
        }
        return count;
      }

      //лишнее число из массива (четное среди нечетных или наоборот)
      function findeNum(arr) {
        const even = arr.filter((item) => item % 2 === 0);
        const odd = arr.filter((item) => item % 2 !== 0);
        if (even.length > odd.length) {
          return odd[0];
        } else {
          return even[0];
        }
      }

      // Сколько раз брошенный с крыши мяч будет виден из окна (учитывая первый бросок с крыши и дальнейшие его подпрыгивания)
      function bouncingBall(h, bounce, window) {
        let vision = 1;
        let afterJump = h;
        if (bounce == 1 || bounce < 0 || h == window || h < window) {
          return -1;
        } else {
          for (i = 0; afterJump > window; i++) {
            afterJump *= bounce;
            afterJump > window ? (vision += 2) : (vision += 0);
          }
        }
        return vision;
      }

      //шифровка текста (сначала прибавляются нечетные символы между собой, потом четные, и все это в итоге в одну строку превращается)
      function encrypt(text, n) {
        if (!text || n <= 0) return text;
        while (n--) {
          let result = "";
          for (i = 1; i < text.length; i += 2) {
            result += text[i];
          }
          for (j = 0; j < text.length; j += 2) {
            result += text[j];
          }
          text = result;
        }
        return text;
      }

      //дешифровка текста из вышестоящей функции (но нужно гадать цифру 'n')
      function decrypt(text, n) {
        if (!text || n <= 0) return text;
        let result = new Array(text.length);
        while (n--) {
          let j = 0;
          for (let i = 1; i < result.length; i += 2) {
            result[i] = text[j++];
          }
          for (let i = 0; i < result.length; i += 2) {
            result[i] = text[j++];
          }
          text = result.join("");
        }
        return text;
      }

      //perimeter calc

      function perimeter(arr) {
        let total = 0;
        let one = "";
        let two = "";
        arr.forEach((el) => {
          one = el;
          for (i = 0; i < el.length; i++) {
            el[i] == "X" ? (total += 4) : null;
            el[i + 1] == "X" && el[i] == "X" ? (total -= 2) : null;
          }
          console.log(one, two);
          for (j = 0; j < one.length; j++) {
            one[j] == "X" && two[j] == "X" ? (total -= 2) : null;
          }
          console.log(total);
          one = "";
          two = el;
        });
        return "Total land perimeter: " + total;
      }

      //проверка на наличие символов и пробелов в строке (при наличии возвращает false)
      function alphanumeric(str) {
        let pattern = /^[a-z\d]+$/i;
        return pattern.test(str);
      }

      // проверка на правильный порядок и количество скобок (отк и закр).
      function bracked(str) {
        let open = [];
        let close = [];
        let result = true;
        if (!str.length) return true;
        for (i = 0; i < str.length; i++) {
          str[i] == "(" ? open.push(str[i]) : close.push(str[i]);
          close.length > open.length ? (result = false) : (result = result);
          if (!result) return result;
        }
        close.length == open.length ? (result = true) : (result = false);
        return result;
      }

      // Даны два массива строк a1и a2возвращается отсортированный массив rв лексикографическом порядке, строки которого a1являются подстроками строк a2.
      function inArray(a, b) {
        let arr = [];
        let word = "";
        if (!a.length || !b.length) return arr;
        a.forEach((el) => {
          b.forEach((item) => {
            for (i = 0; i < el.length; i++) {
              for (j = 0; j < item.length; j++) {
                item.substr(j, el.length) !== undefined ||
                item.substr(j, el.length) !== ""
                  ? (word = item.substr(j, el.length))
                  : (word = "");
                el == word && !arr.includes(word) ? arr.push(word) : null;
              }
            }
          });
        });
        return arr.sort();
        // return a.filter((item) => b.find((el) => el.match(item))).sort();
      }

      //Дан массив целых чисел, найдите то, которое встречается (минимально)нечетное количество раз.

      function findeOdd(arr) {
        return arr.reduce((acc, cur) => acc ^ cur);
      }

      function formula(a, b, c) {
        let q = "?";
        if (
          (a !== q && typeof a == "string") ||
          (b !== q && typeof b == "string") ||
          (c !== q && typeof c == "string")
        )
          return null;
        if (!a || !b || !c) return null;
        if ((a == q && b == q) || (a == q && c == q) || (b == q && c == q))
          return null;
        if (a !== q && b !== q && c !== q) {
          return b / c == a ? true : false;
        }
        if (a == q && b !== q && c !== q)
          return Math.round((b / c) * 1000) / 1000;
        if (a !== q && b == q && c !== q)
          return Math.round(a * c * 1000) / 1000;
        if (a !== q && b !== q && c == q)
          return Math.round((b / a) * 1000) / 1000;
      }

      // количество нулей в конце факториала переданного числа
      function zeros(a) {
        let result = 0;
        for (a; a > 0; ) {
          a = Math.floor(a / 5);
          result += a;
        }
        return result;
      }
    </script>
  </body>
</html>
